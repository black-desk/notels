package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"os"
	"strings"
	"text/template"
)

var adaptorTemplate string = `// Code generated by "jsonrpc2gen". DO NOT EDIT

{{typeCheck .}}

package rpc

import (
        "%[1]s"
        "context"
        "encoding/json"
        "github.com/black-desk/notels/pkg/jsonrpc2"

)

type %[3]sJSONRPCAdaptor struct {
        service %[2]s.%[3]s
}

func New%[3]sJSONRPCAdaptor( service %[2]s.%[3]s ) *%[3]sJSONRPCAdaptor {
        return &%[3]sJSONRPCAdaptor{
                service: service,
        }
}

func (a*%[3]sJSONRPCAdaptor) Call(
        ctx context.Context,
        method string,
        params json.RawMessage,
) (result json.RawMessage, jsonrpcErr jsonrpc2.Error) {

        var err error
        var errorData json.RawMessage
        var methodErr error
        var code jsonrpc2.Code
        var paramsUnmarshal bool
        var call bool
        var errorDataUnmarshal bool

        defer func (){
                jsonrpcErr = jsonrpc2.AnalysisError(err, errorData,code,methodErr, paramsUnmarshal,call,errorDataUnmarshal)
                return
        }()

{{range .}}
        {{if isRequest .}}
                {{$name := index .Names 0}}

        if method == {{getJsonName .Comment}} {
                var tmpResult {{getResultType "%[2]s" .}}
                {{if hasParams .}}
                var tmpParams {{getParamsType "%[2]s" .}}
                err = json.Unmarshal(params, &tmpParams)
                if err != nil {
                        return
                }
                {{end}}
                paramsUnmarshal = true
                {{if hasErrorData .}}
                var tmpErrorData {{getErrorDataType "%[2]s" .}}
                {{end}}
                tmpResult, {{if hasErrorData .}}tmpErrorData, {{end}}code, methodErr = a.service.{{$name}}(ctx{{if hasParams .}}, tmpParams{{end}})
                call = true
                {{if hasErrorData .}}
                if tmpErrorData != nil {
                        errorData, err =json.Marshal(tmpErrorData)
                        if err != nil {
                                return
                        }
                }
                {{end}}
                errorDataUnmarshal = true
                if tmpResult != nil {
                        result, err = json.Marshal(tmpResult)
                        if err != nil {
                                return
                        }
                }
                return
        }
        {{end}}
{{end}}
        return
}

func (a*%[3]sJSONRPCAdaptor) Notify(
        ctx context.Context,
        method string,
        params json.RawMessage,
) (err error) {
{{range .}}
        {{$type:=isRequest .}}
        {{if not $type}}
                {{$name := index .Names 0}}
        if method == {{getJsonName .Comment}} {
                {{if hasParams .}}
                var tmpParams {{getParamsType "%[2]s" .}}
                err = json.Unmarshal(params, &tmpParams)
                if err != nil {
                        return
                }
                {{end}}
                err = a.service.{{$name}}(ctx{{if hasParams .}}, tmpParams{{end}})
                return
        }
        {{end}}
{{end}}
        return
}

var _ jsonrpc2.Adaptor = &%[3]sJSONRPCAdaptor{}
`

var adaptorTemplateTypeCheck = func([]*ast.Field) string { return "" }
var adaptorTemplateIsRequest = func(f *ast.Field) bool {
	return strings.Contains(f.Comment.Text(), "request")
}
var adaptorTemplateGetJsonName = func(comment *ast.CommentGroup) string {
	text := comment.Text()[len("jsonrpc2gen:request"):]
	if strings.Contains(comment.Text(), "notification") {
		text = comment.Text()[len("jsonrpc2gen:notification"):]
	}
	return text[:len(text)-1]
}

var adaptorTemplateGetResultType = func(packageName string, f *ast.Field) string {
	switch v := f.Type.(*ast.FuncType).Results.List[0].Type.(type) {
	case *ast.StarExpr:
		return "*" + packageName + "." + v.X.(*ast.Ident).Name
	case *ast.ArrayType:
		return "[]" + packageName + "." + v.Elt.(*ast.Ident).Name
	default:
		log.Fatalw("unexpected type",
			"v", v,
			"f", adaptorTemplateGetJsonName(f.Comment),
		)
		panic("")
	}
}
var adaptorTemplateHasParams = func(f *ast.Field) bool {
	return len(f.Type.(*ast.FuncType).Params.List) == 2
}

var adaptorTemplateGetParamsType = func(packageName string, f *ast.Field) string {
	switch v := f.Type.(*ast.FuncType).Params.List[1].Type.(type) {
	case *ast.StarExpr:
		return "*" + packageName + "." + v.X.(*ast.Ident).Name
	case *ast.ArrayType:
		return "[]" + packageName + "." + v.Elt.(*ast.Ident).Name
	default:
		log.Fatalw("unexpected type",
			"v", v,
			"f", adaptorTemplateGetJsonName(f.Comment),
		)
		panic("")
	}
}
var adaptorTemplateHasErrorData = func(f *ast.Field) bool {
	return len(f.Type.(*ast.FuncType).Results.List) == 4
}

var adaptorTemplateGetErrorDataType = func(packageName string, f *ast.Field) string {
	switch v := f.Type.(*ast.FuncType).Results.List[1].Type.(type) {
	case *ast.StarExpr:
		return "*" + packageName + "." + v.X.(*ast.Ident).Name
	case *ast.ArrayType:
		return "[]" + packageName + "." + v.Elt.(*ast.Ident).Name
	default:
		log.Fatalw("unexpected type",
			"v", v,
			"f", adaptorTemplateGetJsonName(f.Comment),
		)
		panic("")
	}
}

func generateAdaptor(
	packagePath string,
	sourcePackage *ast.Package,
	interfaceName string,
	interfaceType *ast.InterfaceType,
	fset *token.FileSet,
) {
	log.Infow("generating jsonrpc 2.0 adaptor",
		"from package", packagePath+" "+sourcePackage.Name,
		"interface name", interfaceName,
		"pos", fset.Position(interfaceType.Pos()))

	for i := range interfaceType.Methods.List {
		msgType := "request"
		if strings.Contains(
			interfaceType.Methods.List[i].Comment.Text(),
			"notification",
		) {
			msgType = "notification"
		}
		log.Debugw(
			msgType,
			"go",
			interfaceType.Methods.List[i].Names[0].String(),
			"json",
			interfaceType.Methods.List[i].Comment.Text(),
			"pos",
			fset.Position(interfaceType.Methods.List[i].Pos()),
		)
	}

	fileName := fmt.Sprintf(
		"%s_adaptor_gen.go",
		strings.ToLower(interfaceName),
	)
	genFile, err := os.OpenFile(
		fileName,
		os.O_CREATE|os.O_WRONLY|os.O_TRUNC,
		0644,
	)
	if err != nil {
		log.Fatalw("failed to open file",
			"name", fileName,
			"error", err)
	}
	defer genFile.Close()

	funcs := map[string]any{
		"typeCheck":        adaptorTemplateTypeCheck,
		"getJsonName":      adaptorTemplateGetJsonName,
		"isRequest":        adaptorTemplateIsRequest,
		"getResultType":    adaptorTemplateGetResultType,
		"hasParams":        adaptorTemplateHasParams,
		"getParamsType":    adaptorTemplateGetParamsType,
		"hasErrorData":     adaptorTemplateHasErrorData,
		"getErrorDataType": adaptorTemplateGetErrorDataType,
	}

	codeTemplate, err := template.New(
		fmt.Sprintf("%s_adaptor", strings.ToLower(interfaceName)),
	).Funcs(funcs).Parse(fmt.Sprintf(adaptorTemplate, packagePath, sourcePackage.Name, interfaceName))
	if err != nil {
		log.Fatalw("failed to parse template for or type",
			"error", err)
	}

	err = codeTemplate.Execute(genFile, interfaceType.Methods.List)
	if err != nil {
		log.Fatalw("failed to execute template for or type",
			"error", err)
	}
}
