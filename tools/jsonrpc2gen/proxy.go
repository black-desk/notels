package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"os"
	"strings"
	"text/template"
)

var proxyTemplate string = `// Code generated by "jsonrpc2gen". DO NOT EDIT

{{typeCheck .}}

package rpc

import (
        "%[1]s"
        "context"
        "encoding/json"
        "github.com/black-desk/notels/pkg/jsonrpc2"
        "github.com/google/uuid"
)

type %[3]sJSONRPCProxy struct {
        conn *jsonrpc2.Conn
}

func New%[3]sJSONRPCProxy ( conn *jsonrpc2.Conn ) *%[3]sJSONRPCProxy {
        return &%[3]sJSONRPCProxy{
                conn: conn,
        }
}

{{range .}}
        {{$name := index .Names 0}}
        {{if isRequest .}}
func (p *%[3]sJSONRPCProxy){{$name}}(
        ctx context.Context,
        {{if hasParams .}}params {{getParamsType "%[2]s" .}},{{end}}
) (
        result {{getResultType "%[2]s" .}},
        {{if hasErrorData .}}errorData {{getErrorDataType "%[2]s" .}},{{end}}
        code jsonrpc2.Code,
        err error,
) {
        var requestMsg jsonrpc2.RequestMessage
        requestMsg.Version = "2.0"
        var uuidStr jsonrpc2.String = jsonrpc2.String(uuid.New().String())
        requestMsg.ID = &uuidStr
        requestMsg.Method = {{getJsonName .Comment}}

                {{if hasParams .}}
        requestMsg.Params,err=json.Marshal(params)
        if err != nil {
                return
        }
                {{end}}

        var responseMessage *jsonrpc2.ResponseMessage
        responseMessage, err = p.conn.SendMessage(&requestMsg)

        if responseMessage.Result != nil {
                err = json.Unmarshal(responseMessage.Result, &result)
                if err != nil {
                        return
                }
        }
                {{if hasErrorData .}}
        if responseMessage.Error != nil {
                err = json.Unmarshal(responseMessage.Error.Data, &errorData)
                if err != nil {
                        return
                }
        }
                {{end}}
        return
}
        {{else}}
func (p *%[3]sJSONRPCProxy){{$name}}(
        ctx context.Context,
        {{if hasParams .}}params {{getParamsType "%[2]s" .}},{{end}}
) (
        err error,
) {
        var notificationMsg jsonrpc2.RequestMessage
        notificationMsg.Version = "2.0"
        notificationMsg.Method = {{getJsonName .Comment}}
                {{if hasParams .}}
        notificationMsg.Params,err=json.Marshal(params)
        if err != nil {
                return
        }
                {{end}}

        _, err = p.conn.SendMessage(&notificationMsg)
        return
}
        {{end}}
{{end}}

var _ %[2]s.%[3]s = &%[3]sJSONRPCProxy{}

`

func generateProxy(
	packagePath string,
	sourcePackage *ast.Package,
	interfaceName string,
	interfaceType *ast.InterfaceType,
	fset *token.FileSet,
) {
	log.Infow("generating jsonrpc 2.0 proxy",
		"from package", packagePath+" "+sourcePackage.Name,
		"interface name", interfaceName,
		"pos", fset.Position(interfaceType.Pos()))

	for i := range interfaceType.Methods.List {
		log.Debugw(
			"method",
			"go",
			interfaceType.Methods.List[i].Names[0].String(),
			"json",
			interfaceType.Methods.List[i].Comment.Text(),
			"pos",
			fset.Position(interfaceType.Methods.List[i].Pos()),
		)
	}

	fileName := fmt.Sprintf(
		"%s_proxy_gen.go",
		strings.ToLower(interfaceName),
	)
	genFile, err := os.OpenFile(
		fileName,
		os.O_CREATE|os.O_WRONLY|os.O_TRUNC,
		0644,
	)
	if err != nil {
		log.Fatalw("failed to open file",
			"name", fileName,
			"error", err)
	}
	defer genFile.Close()

	funcs := map[string]any{
		"typeCheck":        adaptorTemplateTypeCheck,
		"getJsonName":      adaptorTemplateGetJsonName,
		"isRequest":        adaptorTemplateIsRequest,
		"getResultType":    adaptorTemplateGetResultType,
		"hasParams":        adaptorTemplateHasParams,
		"getParamsType":    adaptorTemplateGetParamsType,
		"hasErrorData":     adaptorTemplateHasErrorData,
		"getErrorDataType": adaptorTemplateGetErrorDataType,
	}

	codeTemplate, err := template.New(
		fmt.Sprintf("%s_proxy", strings.ToLower(interfaceName)),
	).Funcs(funcs).Parse(fmt.Sprintf(proxyTemplate, packagePath, sourcePackage.Name, interfaceName))
	if err != nil {
		log.Fatalw("failed to parse template for or type",
			"error", err)
	}

	err = codeTemplate.Execute(genFile, interfaceType.Methods.List)
	if err != nil {
		log.Fatalw("failed to execute template for or type",
			"error", err)
	}

}
